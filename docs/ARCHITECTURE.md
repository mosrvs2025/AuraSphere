# AuraSphere Architecture

AuraSphere is orchestrated from `App.tsx`, which acts as both router and state manager. The sections below describe how data and components flow through the application.

## High-Level Component Graph
```
App.tsx
└─ UserContext.Provider
   ├─ Sidebar (desktop nav)
   ├─ <div class="flex-1">
   │   ├─ <main id="main-content">
   │   │   ├─ GlobalHeader (only on the Discover surface)
   │   │   └─ renderActiveView(...)
   │   └─ BottomNavBar (mobile nav when no overlays are active)
   ├─ Modal & overlay layer (conditionally rendered)
   │   ├─ CreateRoomModal
   │   ├─ EditProfileModal
   │   ├─ AvatarCustomizer
   │   ├─ MediaViewerModal
   │   ├─ CreateHubModal
   │   ├─ InAppBrowser
   │   └─ PostCreationAnimation
   └─ MiniPlayer (floating when a room is active but minimized)
```
The layout toggles between desktop and mobile navigation automatically because both the sidebar and bottom nav are always mounted and styled via Tailwind breakpoints.

## Active View Resolution
`renderActiveView` inside `App.tsx` follows a deterministic priority stack before falling back to the `activeView` switch:
```
renderActiveView priority
┌──────────────────────────────────────────────────────┐
│ viewingProfile?        → <UserProfile />            │
│ activeConversation?    → <ConversationView />       │
│ viewingPost?           → <PostDetailView />         │
│ createPostFile?        → <CreatePostView />         │
│ createNote?            → <CreateNoteView />         │
│ else switch(activeView)                             │
│    'home'        → <TrendingView />                 │
│    'aurasphere'  → <AuraSphereView />               │
│    'messages'    → <MessagesView />                 │
│    'scheduled'   → <ScheduledView />                │
│    'profile'     → <UserProfile />                  │
│    'notifications' → <NotificationsView />          │
│    'my-studio'   → <MyStudioView /> (placeholder)   │
│    'room'        → <RoomView />                     │
│    'search'      → <GlobalSearchView />             │
└──────────────────────────────────────────────────────┘
```
`isSubViewActive` gates the sidebar header and bottom nav so modal-style views take over the canvas without duplicated controls.

## State Ownership
`App.tsx` owns the majority of UI state:

| State variable | Purpose | Key producers / consumers |
| -------------- | ------- | ------------------------- |
| `activeView` (`ActiveView`) | Determines which surface is visible. | Updated by navigation components (`Sidebar`, `BottomNavBar`, `GlobalHeader`) and mini player. |
| `rooms` (`Room[]`) | Collection of live and scheduled rooms. | Seeded by `generateRooms`; mutated by room creation and `handleUpdateRoom`. |
| `posts` (`DiscoverItem` subset) | Media and text posts for the discovery feed. | Created in `handleCreatePost`; consumed by `TrendingView`, `ScheduledView`, and detail modals. |
| `conversations` (`Conversation[]`) | Direct message threads. | Generated by `generateConversations`; consumed by `MessagesView`/`ConversationView`. |
| `activeRoom` (`Room \| null`) | Currently joined room. | Set via `handleEnterRoom` and cleared in `handleLeaveRoom`; drives `RoomView` and `MiniPlayer`. |
| `viewingProfile`, `viewingPost`, `viewingMedia` | Control profile and media overlays. | Toggled from discovery cards, profile views, and post viewers. |
| `isCreateRoomModalOpen`, `isEditProfileModalOpen`, etc. | Boolean flags for overlays. | Triggered by nav, create hub, or in-view actions. |
| `curationTab`, `activeFilter` | Discovery feed filters. | Updated in `GlobalHeader`; used by `TrendingView` to shape the feed. |
| `searchQuery`, `browserUrl`, `mainScrollTop` | Support utilities for search and header animations. | Updated by `GlobalSearchView`, `InAppBrowser`, and the `<main>` scroll handler. |

Because state lives centrally, callbacks such as `handleCreatePost`, `handleVote`, or `handleSendMessage` always reconcile updates before propagating them back down as props.

## Mock Data Pipeline
```
generateUsers(count)
      │
      ├─► allUsers (shared pool)
      │     │
      │     ├─► generateRooms(allUsers) ──► rooms state
      │     ├─► generatePosts(allUsers) ──► posts state
      │     └─► generateConversations(allUsers, currentUser) ──► conversations state
      │
      └─► generateDiscoverItems(allUsers, rooms, posts) ──► discovery feed
```
The initial user acts as the logged-in profile (`currentUser`). Derived entities (followers/following, requests to speak, poll votes) reference shared user objects, giving the UI enough richness for realistic rendering without a backend.

## Context Layers
- **`UserContext`** exposes the active user plus `followUser`, `unfollowUser`, and `getUserById`. Components such as `Sidebar`, `DiscoverCard`, and `RoomView` consume it to render identity-aware UI.
- **`RoomActionsContext`** currently provides a stubbed `onToggleScreenShare`. When real-time infrastructure is introduced, this context can mediate WebRTC or server-driven state changes without threading callbacks through every component.

## Gemini Service Integration
`services/geminiService.ts` initializes the GoogleGenAI client using `process.env.API_KEY` / `process.env.GEMINI_API_KEY` (populated through Vite). Three helpers feed UI features:
- `generateIcebreakers(topic)` → used by `HostControls`.
- `summarizeChat(messages)` → surfaced in `AiAssistantPanel`.
- `generateAvatarImage()` → called from `AvatarCustomizer`.
Each helper gracefully handles API failures by logging errors and returning fallback content so the UI remains responsive.

## Styling & Layout
Tailwind CSS classes (applied inline via `className`) manage layout, breakpoints, motion, and theming. Utility classes such as `animate-fade-in`, `backdrop-blur`, and responsive grid utilities give components like `TrendingView`, `ScheduledView`, and `AuraSphereView` distinctive motion and structure without custom CSS files.

## Environment Bridging
`vite.config.ts` loads `.env` entries and injects them as stringified constants for `process.env.API_KEY` and `process.env.GEMINI_API_KEY`. This allows browser-side modules to reference `process.env` safely, even though the actual values are resolved at build time.
